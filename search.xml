<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ehcache配置文件详解</title>
    <url>/2020/02/27/ehcache%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ehcache xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation&#x3D;&quot;..&#x2F;config&#x2F;ehcache.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    The ehcache-failsafe.xml is a default configuration for ehcache, if an ehcache.xml is not configured.</span><br><span class="line">    如果未配置ehcache.xml配置文件，ehcache-failsafe.xml就是ehcache的默认配置。</span><br><span class="line"></span><br><span class="line">    The diskStore element is optional. It must be configured if you have overflowToDisk or diskPersistent enabled</span><br><span class="line">    for any cache. If it is not configured, a warning will be issues and java.io.tmpdir will be used.</span><br><span class="line">    diskStore（磁盘存储）元素是可选的。如果overflowToDisk或diskPersistent开启了，diskStore就必须要配置，要是没有配置将发出警告，并且diskStore将使用java.io.tmpdir。</span><br><span class="line"></span><br><span class="line">    diskStore has only one attribute - &quot;path&quot;. It is the path to the directory where .data and .index files will be created.</span><br><span class="line">    diskStore只有一个属性path（路径）。属性值就是创建.data和.index文件的所在目录。</span><br><span class="line"></span><br><span class="line">    If the path is a Java System Property it is replaced by its value in the</span><br><span class="line">    running VM.</span><br><span class="line">    如果该路径值是Java系统属性，该值将在运行中的虚拟机中被替换。</span><br><span class="line"></span><br><span class="line">    The following properties are translated:</span><br><span class="line">    * user.home - User&#39;s home directory</span><br><span class="line">    * user.dir - User&#39;s current working directory</span><br><span class="line">    * java.io.tmpdir - Default temp file path</span><br><span class="line">    * ehcache.disk.store.dir - A system property you would normally specify on the command line</span><br><span class="line">          e.g. java -Dehcache.disk.store.dir&#x3D;&#x2F;u01&#x2F;myapp&#x2F;diskdir ...</span><br><span class="line">    以下为Java系统属性的对应值：</span><br><span class="line">    * user.home - 用户主目录</span><br><span class="line">    * user.dir - 用户当前工作目录</span><br><span class="line">    * java.io.tmpdir - 默认临时文件路径</span><br><span class="line">    * ehcache.disk.store.dir - 通常在命令行上指定的系统属性</span><br><span class="line">        比如：java -Dehcache.disk.store.dir&#x3D;&#x2F;u01&#x2F;myapp&#x2F;diskdir ...</span><br><span class="line"></span><br><span class="line">    Subdirectories can be specified below the property e.g. java.io.tmpdir&#x2F;one</span><br><span class="line">    子目录可以在属性下指定 比如：java.io.tmpdir&#x2F;one</span><br><span class="line"></span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;diskStore path&#x3D;&quot;java.io.tmpdir&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    Specifies a CacheManagerEventListenerFactory, be used to create a CacheManagerPeerProvider,</span><br><span class="line">    which is notified when Caches are added or removed from the CacheManager.</span><br><span class="line">    指定CacheManagerEventListenerFactory用来创建CacheManagerPeerProvider，</span><br><span class="line">    当从CacheManager（缓存管理器）中添加或删除缓存时都会提醒CacheManagerPeerProvider。</span><br><span class="line"></span><br><span class="line">    The attributes of CacheManagerEventListenerFactory are:</span><br><span class="line">    * class - a fully qualified factory class name</span><br><span class="line">    * properties - comma separated properties having meaning only to the factory.</span><br><span class="line">    CacheManagerEventListenerFactory的属性：</span><br><span class="line">    * class - 完全限定的工厂类名</span><br><span class="line">    * properties - 逗号分隔属性仅对该工厂有效</span><br><span class="line"></span><br><span class="line">    Sets the fully qualified class name to be registered as the CacheManager event listener.</span><br><span class="line">    设置要注册为CacheManager事件侦听器的完全限定类名。</span><br><span class="line"></span><br><span class="line">    The events include:</span><br><span class="line">    * adding a Cache</span><br><span class="line">    * removing a Cache</span><br><span class="line">    事件包括：</span><br><span class="line">    *添加缓存</span><br><span class="line">    *删除缓存</span><br><span class="line"></span><br><span class="line">    Callbacks to listener methods are synchronous and unsynchronized. It is the responsibility</span><br><span class="line">    of the implementer to safely handle the potential performance and thread safety issues</span><br><span class="line">    depending on what their listener is doing.</span><br><span class="line">    监听方法的回调有同步和非同步，我们在实现方法回调的时候需要考虑到安全问题，</span><br><span class="line">    包括潜在的性能问题和线程安全问题。如何安全的实现取决于监听器主要是做什么的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    If no class is specified, no listener is created. There is no default.</span><br><span class="line">    如果没有指定类名，监听器也没有指定，那也没有默认值。</span><br><span class="line"></span><br><span class="line">    &lt;cacheManagerEventListenerFactory class&#x3D;&quot;&quot; properties&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    (Enable for distributed operation)</span><br><span class="line">    （用于分布式操作）</span><br><span class="line"></span><br><span class="line">    Specifies a CacheManagerPeerProviderFactory which will be used to create a</span><br><span class="line">    CacheManagerPeerProvider, which discovers other CacheManagers in the cluster.</span><br><span class="line">    指定用于创建CacheManagerPeerProvider的CacheManagerPeerProviderFactory，</span><br><span class="line">    CacheManagerPeerProvider作用：发现集群中的其他的缓存管理器。</span><br><span class="line"></span><br><span class="line">    The attributes of cacheManagerPeerProviderFactory are:</span><br><span class="line">    * class - a fully qualified factory class name</span><br><span class="line">    * properties - comma separated properties having meaning only to the factory.</span><br><span class="line">    cacheManagerPeerProviderFactory的属性：</span><br><span class="line">    * class - 完全限定的工厂类名</span><br><span class="line">    * properties - 逗号分隔属性仅对该工厂有效</span><br><span class="line"></span><br><span class="line">    Ehcache comes with a built-in RMI-based distribution system with two means of discovery of</span><br><span class="line">    CacheManager peers participating in the cluster:</span><br><span class="line">    * automatic, using a multicast group. This one automatically discovers peers and detects</span><br><span class="line">      changes such as peers entering and leaving the group</span><br><span class="line">    * manual, using manual rmiURL configuration. A hardcoded list of peers is provided at</span><br><span class="line">      configuration time.</span><br><span class="line">    Ehcache提供内置的基于RMI（远程方法调用）的分布式系统，该系统有两种方式发现参与到集群的（对个）缓存管理器：</span><br><span class="line">    * 自动：使用多播组。自动发现缓存管理器以及检测缓存管理器的变化，比如缓存管理器的进入和离开（缓存管理器组）。</span><br><span class="line">    * 手动：使用手动配置rmiURL。在配置时，会提供缓存管理器的硬编码列表。</span><br><span class="line"></span><br><span class="line">    Configuring Automatic Discovery:</span><br><span class="line">    Automatic discovery is configured as per the following example:</span><br><span class="line">    配置自动发现：</span><br><span class="line">    自动发现的配置正如以下的例子：</span><br><span class="line">    &lt;cacheManagerPeerProviderFactory</span><br><span class="line">                        class&#x3D;&quot;net.sf.ehcache.distribution.RMICacheManagerPeerProviderFactory&quot;</span><br><span class="line">                        properties&#x3D;&quot;peerDiscovery&#x3D;automatic, multicastGroupAddress&#x3D;230.0.0.1,</span><br><span class="line">                                    multicastGroupPort&#x3D;4446, timeToLive&#x3D;32&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    Valid properties are:</span><br><span class="line">    * peerDiscovery (mandatory) - specify &quot;automatic&quot;</span><br><span class="line">    * multicastGroupAddress (mandatory) - specify a valid multicast group address</span><br><span class="line">    * multicastGroupPort (mandatory) - specify a dedicated port for the multicast heartbeat</span><br><span class="line">      traffic</span><br><span class="line">    * timeToLive - specify a value between 0 and 255 which determines how far the packets will propagate.</span><br><span class="line">      By convention, the restrictions are:</span><br><span class="line">      0   - the same host</span><br><span class="line">      1   - the same subnet</span><br><span class="line">      32  - the same site</span><br><span class="line">      64  - the same region</span><br><span class="line">      128 - the same continent</span><br><span class="line">      255 - unrestricted</span><br><span class="line"></span><br><span class="line">    有效属性：</span><br><span class="line">     * peerDiscovery (mandatory) - 指定自动&quot;automatic&quot;</span><br><span class="line">    * multicastGroupAddress (mandatory) - 指定一个有效的多播组地址</span><br><span class="line">    * multicastGroupPort (mandatory) - 指定一个专用端口号，用于监测多播组心跳</span><br><span class="line">    * timeToLive - 指定0-255之间的一个值，用于控制数据包传送速率</span><br><span class="line">      按照惯例，这些限制是：</span><br><span class="line">      0   - 同一主机</span><br><span class="line">      1   - 同一子网</span><br><span class="line">      32  - 同一地点</span><br><span class="line">      64  - 同一地区</span><br><span class="line">      128 - 同一大陆</span><br><span class="line">      255 - 无限制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Configuring Manual Discovery:</span><br><span class="line">    Manual discovery is configured as per the following example:</span><br><span class="line">    配置手动发现：</span><br><span class="line">    手动发现的配置正如以下的例子：</span><br><span class="line">    &lt;cacheManagerPeerProviderFactory class&#x3D;</span><br><span class="line">                          &quot;net.sf.ehcache.distribution.RMICacheManagerPeerProviderFactory&quot;</span><br><span class="line">                          properties&#x3D;&quot;peerDiscovery&#x3D;manual,</span><br><span class="line">                          rmiUrls&#x3D;&#x2F;&#x2F;server1:40000&#x2F;sampleCache1|&#x2F;&#x2F;server2:40000&#x2F;sampleCache1</span><br><span class="line">                          | &#x2F;&#x2F;server1:40000&#x2F;sampleCache2|&#x2F;&#x2F;server2:40000&#x2F;sampleCache2&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    Valid properties are:</span><br><span class="line">    * peerDiscovery (mandatory) - specify &quot;manual&quot;</span><br><span class="line">    * rmiUrls (mandatory) - specify a pipe separated list of rmiUrls, in the form</span><br><span class="line">                            &#x2F;&#x2F;hostname:port</span><br><span class="line">    有效属性：</span><br><span class="line">    * peerDiscovery (mandatory) - 指定手动&quot;manual&quot;</span><br><span class="line">    * rmiUrls (mandatory) - 指定rmiUrls的管道分隔列表, 格式为：主机:端口</span><br><span class="line"></span><br><span class="line">    The hostname is the hostname of the remote CacheManager peer. The port is the listening</span><br><span class="line">    port of the RMICacheManagerPeerListener of the remote CacheManager peer.</span><br><span class="line">    主机就是远程的缓存管理器的主机，端口是远程管理器的RMICacheManagerPeerListener的监听端口。</span><br><span class="line"></span><br><span class="line">    &lt;cacheManagerPeerProviderFactory</span><br><span class="line">            class&#x3D;&quot;net.sf.ehcache.distribution.RMICacheManagerPeerProviderFactory&quot;</span><br><span class="line">            properties&#x3D;&quot;peerDiscovery&#x3D;automatic,</span><br><span class="line">                        multicastGroupAddress&#x3D;230.0.0.1,</span><br><span class="line">                        multicastGroupPort&#x3D;4446, timeToLive&#x3D;1&quot;&#x2F;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    (Enable for distributed operation)</span><br><span class="line">    （用于分布式操作）</span><br><span class="line"></span><br><span class="line">    Specifies a CacheManagerPeerListenerFactory which will be used to create a</span><br><span class="line">    CacheManagerPeerListener, which</span><br><span class="line">    listens for messages from cache replicators participating in the cluster.</span><br><span class="line">    指定一个用于创建CacheManagerPeerListener的CacheManagerPeerListenerFactory，</span><br><span class="line">    CacheManagerPeerListener是用于接收来自参与到集群的缓存复制器的消息。</span><br><span class="line"></span><br><span class="line">    The attributes of cacheManagerPeerListenerFactory are:</span><br><span class="line">    class - a fully qualified factory class name</span><br><span class="line">    properties - comma separated properties having meaning only to the factory.</span><br><span class="line">    cacheManagerPeerListenerFactory的属性：</span><br><span class="line">    * class - 完全限定的工厂类名</span><br><span class="line">    * properties - 逗号分隔属性仅对该工厂有效</span><br><span class="line">    </span><br><span class="line">    Ehcache comes with a built-in RMI-based distribution system. The listener component is</span><br><span class="line">    RMICacheManagerPeerListener which is configured using</span><br><span class="line">    RMICacheManagerPeerListenerFactory. It is configured as per the following example:</span><br><span class="line">    Ehcache有一个内置的基于RMI的分布式系统，该系统的监听器组成就是RMICacheManagerPeerListener，</span><br><span class="line">    可以使用RMICacheManagerPeerListenerFactory配置RMICacheManagerPeerListener，配置示例如下：</span><br><span class="line"></span><br><span class="line">    &lt;cacheManagerPeerListenerFactory</span><br><span class="line">        class&#x3D;&quot;net.sf.ehcache.distribution.RMICacheManagerPeerListenerFactory&quot;</span><br><span class="line">        properties&#x3D;&quot;hostName&#x3D;fully_qualified_hostname_or_ip,</span><br><span class="line">                    port&#x3D;40001,</span><br><span class="line">                    socketTimeoutMillis&#x3D;120000&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    All properties are optional. They are:</span><br><span class="line">    * hostName - the hostName of the host the listener is running on. Specify</span><br><span class="line">      where the host is multihomed and you want to control the interface over which cluster</span><br><span class="line">      messages are received. Defaults to the host name of the default interface if not</span><br><span class="line">      specified.</span><br><span class="line">    * port - the port the listener listens on. This defaults to a free port if not specified.</span><br><span class="line">    * socketTimeoutMillis - the number of ms client sockets will stay open when sending</span><br><span class="line">      messages to the listener. This should be long enough for the slowest message.</span><br><span class="line">      If not specified it defaults 120000ms.</span><br><span class="line"></span><br><span class="line">    &lt;cacheManagerPeerListenerFactory</span><br><span class="line">            class&#x3D;&quot;net.sf.ehcache.distribution.RMICacheManagerPeerListenerFactory&quot;&#x2F;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- Cache configuration.</span><br><span class="line"></span><br><span class="line">    The following attributes are required.</span><br><span class="line"></span><br><span class="line">    name:</span><br><span class="line">    Sets the name of the cache. This is used to identify the cache. It must be unique.</span><br><span class="line"></span><br><span class="line">    maxElementsInMemory:</span><br><span class="line">    Sets the maximum number of objects that will be created in memory (0 &#x3D;&#x3D; no limit)</span><br><span class="line"></span><br><span class="line">	maxElementsOnDisk:</span><br><span class="line">    Sets the maximum number of objects that will be maintained in the DiskStore</span><br><span class="line">	The default value is zero, meaning unlimited.</span><br><span class="line"></span><br><span class="line">    eternal:</span><br><span class="line">    Sets whether elements are eternal. If eternal,  timeouts are ignored and the</span><br><span class="line">    element is never expired.</span><br><span class="line"></span><br><span class="line">    overflowToDisk:</span><br><span class="line">    Sets whether elements can overflow to disk when the in-memory cache</span><br><span class="line">    has reached the maxInMemory limit.</span><br><span class="line"></span><br><span class="line">    The following attributes are optional.</span><br><span class="line"></span><br><span class="line">    timeToIdleSeconds:</span><br><span class="line">    Sets the time to idle for an element before it expires.</span><br><span class="line">    i.e. The maximum amount of time between accesses before an element expires</span><br><span class="line">    Is only used if the element is not eternal.</span><br><span class="line">    Optional attribute. A value of 0 means that an Element can idle for infinity.</span><br><span class="line">    The default value is 0.</span><br><span class="line"></span><br><span class="line">    timeToLiveSeconds:</span><br><span class="line">    Sets the time to live for an element before it expires.</span><br><span class="line">    i.e. The maximum time between creation time and when an element expires.</span><br><span class="line">    Is only used if the element is not eternal.</span><br><span class="line">    Optional attribute. A value of 0 means that and Element can live for infinity.</span><br><span class="line">    The default value is 0.</span><br><span class="line"></span><br><span class="line">    diskPersistent:</span><br><span class="line">    Whether the disk store persists between restarts of the Virtual Machine.</span><br><span class="line">    The default value is false.</span><br><span class="line"></span><br><span class="line">    diskExpiryThreadIntervalSeconds:</span><br><span class="line">    The number of seconds between runs of the disk expiry thread. The default value</span><br><span class="line">    is 120 seconds.</span><br><span class="line"></span><br><span class="line">    diskSpoolBufferSizeMB:</span><br><span class="line">    This is the size to allocate the DiskStore for a spool buffer. Writes are made</span><br><span class="line">    to this area and then asynchronously written to disk. The default size is 30MB.</span><br><span class="line">    Each spool buffer is used only by its cache. If you get OutOfMemory errors consider</span><br><span class="line">    lowering this value. To improve DiskStore performance consider increasing it. Trace level</span><br><span class="line">    logging in the DiskStore will show if put back ups are occurring.</span><br><span class="line"></span><br><span class="line">    memoryStoreEvictionPolicy:</span><br><span class="line">    Policy would be enforced upon reaching the maxElementsInMemory limit. Default</span><br><span class="line">    policy is Least Recently Used (specified as LRU). Other policies available -</span><br><span class="line">    First In First Out (specified as FIFO) and Less Frequently Used</span><br><span class="line">    (specified as LFU)</span><br><span class="line"></span><br><span class="line">    Cache elements can also contain sub elements which take the same format of a factory class</span><br><span class="line">    and properties. Defined sub-elements are:</span><br><span class="line"></span><br><span class="line">    * cacheEventListenerFactory - Enables registration of listeners for cache events, such as</span><br><span class="line">      put, remove, update, and expire.</span><br><span class="line"></span><br><span class="line">    * bootstrapCacheLoaderFactory - Specifies a BootstrapCacheLoader, which is called by a</span><br><span class="line">      cache on initialisation to prepopulate itself.</span><br><span class="line"></span><br><span class="line">    Each cache that will be distributed needs to set a cache event listener which replicates</span><br><span class="line">    messages to the other CacheManager peers. For the built-in RMI implementation this is done</span><br><span class="line">    by adding a cacheEventListenerFactory element of type RMICacheReplicatorFactory to each</span><br><span class="line">    distributed cache&#39;s configuration as per the following example:</span><br><span class="line"></span><br><span class="line">    &lt;cacheEventListenerFactory class&#x3D;&quot;net.sf.ehcache.distribution.RMICacheReplicatorFactory&quot;</span><br><span class="line">         properties&#x3D;&quot;replicateAsynchronously&#x3D;true,</span><br><span class="line">         replicatePuts&#x3D;true,</span><br><span class="line">         replicateUpdates&#x3D;true,</span><br><span class="line">         replicateUpdatesViaCopy&#x3D;true,</span><br><span class="line">         replicateRemovals&#x3D;true &quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    The RMICacheReplicatorFactory recognises the following properties:</span><br><span class="line"></span><br><span class="line">    * replicatePuts&#x3D;true|false - whether new elements placed in a cache are</span><br><span class="line">      replicated to others. Defaults to true.</span><br><span class="line"></span><br><span class="line">    * replicateUpdates&#x3D;true|false - whether new elements which override an</span><br><span class="line">      element already existing with the same key are replicated. Defaults to true.</span><br><span class="line"></span><br><span class="line">    * replicateRemovals&#x3D;true - whether element removals are replicated. Defaults to true.</span><br><span class="line"></span><br><span class="line">    * replicateAsynchronously&#x3D;true | false - whether replications are</span><br><span class="line">      asynchronous (true) or synchronous (false). Defaults to true.</span><br><span class="line"></span><br><span class="line">    * replicateUpdatesViaCopy&#x3D;true | false - whether the new elements are</span><br><span class="line">      copied to other caches (true), or whether a remove message is sent. Defaults to true.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    * asynchronousReplicationIntervalMillis&#x3D;&lt;number of milliseconds&gt; - The asynchronous</span><br><span class="line">      replicator runs at a set interval of milliseconds. The default is 1000. The minimum</span><br><span class="line">      is 10. This property is only applicable if replicateAsynchronously&#x3D;true</span><br><span class="line"></span><br><span class="line">    * asynchronousReplicationMaximumBatchSize&#x3D;&lt;number of operations&gt; - The maximum</span><br><span class="line">      number of operations that will be batch within a single RMI message.  The default</span><br><span class="line">      is 1000. This property is only applicable if replicateAsynchronously&#x3D;true</span><br><span class="line"></span><br><span class="line">    The RMIBootstrapCacheLoader bootstraps caches in clusters where RMICacheReplicators are</span><br><span class="line">    used. It is configured as per the following example:</span><br><span class="line"></span><br><span class="line">    &lt;bootstrapCacheLoaderFactory</span><br><span class="line">        class&#x3D;&quot;net.sf.ehcache.distribution.RMIBootstrapCacheLoaderFactory&quot;</span><br><span class="line">        properties&#x3D;&quot;bootstrapAsynchronously&#x3D;true, maximumChunkSizeBytes&#x3D;5000000&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    The RMIBootstrapCacheLoaderFactory recognises the following optional properties:</span><br><span class="line"></span><br><span class="line">    * bootstrapAsynchronously&#x3D;true|false - whether the bootstrap happens in the background</span><br><span class="line">      after the cache has started. If false, bootstrapping must complete before the cache is</span><br><span class="line">      made available. The default value is true.</span><br><span class="line"></span><br><span class="line">    * maximumChunkSizeBytes&#x3D;&lt;integer&gt; - Caches can potentially be very large, larger than the</span><br><span class="line">      memory limits of the VM. This property allows the bootstraper to fetched elements in</span><br><span class="line">      chunks. The default chunk size is 5000000 (5MB).</span><br><span class="line"></span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    Mandatory Default Cache configuration. These settings will be applied to caches</span><br><span class="line">    created programmtically using CacheManager.add(String cacheName)</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;defaultCache</span><br><span class="line">            maxElementsInMemory&#x3D;&quot;10000&quot;</span><br><span class="line">            eternal&#x3D;&quot;false&quot;</span><br><span class="line">            timeToIdleSeconds&#x3D;&quot;120&quot;</span><br><span class="line">            timeToLiveSeconds&#x3D;&quot;120&quot;</span><br><span class="line">            maxElementsOnDisk&#x3D;&quot;10000000&quot;</span><br><span class="line">            diskExpiryThreadIntervalSeconds&#x3D;&quot;120&quot;</span><br><span class="line">            memoryStoreEvictionPolicy&#x3D;&quot;LRU&quot;&gt;</span><br><span class="line">        &lt;persistence strategy&#x3D;&quot;localTempSwap&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;defaultCache&gt;</span><br><span class="line">&lt;&#x2F;ehcache&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>ehcache</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux上安装Nginx</title>
    <url>/2020/02/24/Linux%E4%B8%8A%E5%AE%89%E8%A3%85nginx/</url>
    <content><![CDATA[<h3 id="一-安装前准备"><a href="#一-安装前准备" class="headerlink" title="一.安装前准备"></a>一.安装前准备</h3><h4 id="1-安装wget"><a href="#1-安装wget" class="headerlink" title="1.安装wget"></a>1.安装wget</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install wget -y</span><br></pre></td></tr></table></figure>
<h4 id="2-安装gcc编译环境"><a href="#2-安装gcc编译环境" class="headerlink" title="2.安装gcc编译环境"></a>2.安装gcc编译环境</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure>
<h4 id="3-Nginx的http模块需要使用pcre来解析正则表达式"><a href="#3-Nginx的http模块需要使用pcre来解析正则表达式" class="headerlink" title="3.Nginx的http模块需要使用pcre来解析正则表达式"></a>3.Nginx的http模块需要使用pcre来解析正则表达式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install pcre pcre-devel</span><br></pre></td></tr></table></figure>
<h4 id="4-依赖解压包"><a href="#4-依赖解压包" class="headerlink" title="4.依赖解压包"></a>4.依赖解压包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install zlib zlib-devel</span><br></pre></td></tr></table></figure>
<h4 id="5-openssl安装"><a href="#5-openssl安装" class="headerlink" title="5.openssl安装"></a>5.openssl安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二-安装Nginx"><a href="#二-安装Nginx" class="headerlink" title="二.安装Nginx"></a>二.安装Nginx</h3><h4 id="1-官网下载"><a href="#1-官网下载" class="headerlink" title="1.官网下载"></a>1.官网下载</h4><p><a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">Nginx官网下载地址</a><br>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxvf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="3-指定安装目录"><a href="#3-指定安装目录" class="headerlink" title="3.指定安装目录"></a>3.指定安装目录</h4><p>将解压文件移动到/usr/local/目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv nginx-1.16.1 &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure>
<p>进入/usr/local/nginx-1.16.1目录，执行以下命令指定安装目录/usr/local/nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx</span><br></pre></td></tr></table></figure>
<h4 id="4-编译安装"><a href="#4-编译安装" class="headerlink" title="4.编译安装"></a>4.编译安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h4 id="5-启动与停止"><a href="#5-启动与停止" class="headerlink" title="5.启动与停止"></a>5.启动与停止</h4><p>进入/nginx/sbin目录<br>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure>
<p>强制停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -s stop</span><br></pre></td></tr></table></figure>
<p>有序停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;nginx -s quit</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>努力赚钱</title>
    <url>/2020/02/12/%E5%8A%AA%E5%8A%9B%E8%B5%9A%E9%92%B1/</url>
    <content><![CDATA[<p>&emsp;&emsp;昨天睡觉前刷微博，看到一对广东夫妇的故事，妻子怀二胎染上新型肺炎，为治疗家里已经借了二十多万，在国家发布免费为患者治疗的前一天丈夫放弃了继续使用人工肺。看完为他们感到惋惜，然后想：我一定要努力赚钱，当“钱”可以挽救家人“生命”的时候，我就可以不用做出选择了。<br>&emsp;&emsp;上午看朋友圈，刷到一篇推文“俄罗斯你咋把物资扔下就跑了？不写两句诗？”。主要内容就是：在本次“肺炎”事件下，通过对比多国对中国的支援行为，强烈表扬了俄罗斯。俄罗斯这种做好事不留名的行为让我等中国人感到深深敬佩，所以我要努力攒钱，完成人生第一次出国游，为老铁的旅游业尽一份真·绵薄之力。<br>&emsp;&emsp;《萤火虫之墓》中说：“珍惜今天，珍惜现在，谁知道明天和意外，哪一个先来”。之前一直觉得自己不是一个有未来的人，终其一生的努力，最好的结局也不过是活成最普通的样子。现在想想，能活成普通的样子已经很好了。感谢国家和政府的努力，今天的我普通地戴着口罩出门，普通地健康的活着。</p>
]]></content>
      <categories>
        <category>日记</category>
        <category>愿望清单</category>
      </categories>
      <tags>
        <tag>武汉肺炎</tag>
      </tags>
  </entry>
  <entry>
    <title>武汉肺炎-自己煮饭第二天</title>
    <url>/2020/02/11/%E6%AD%A6%E6%B1%89%E8%82%BA%E7%82%8E-%E8%87%AA%E5%B7%B1%E7%85%AE%E9%A5%AD%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    <content><![CDATA[<p>&emsp;&emsp;实际上，这是第三天。8号下午四点多坐姑父的车到了小区，然后出去了一次，拿快递–在微信朋友圈看到买的酒精，顺便在小区门口买了调味品、水果……<br>&emsp;&emsp;今天早上煮了汤圆，黑芝麻馅的，齁甜；中午，炸了葱油，做了一个葱油拌面，配了点香肠，感觉自己有点做饭的天赋，哈哈哈；晚上，煮了莴苣蛋汤，主食是番薯饼（从老家带过来的）。<br>&emsp;&emsp;好饿，想念红烧肉的第一天，想念炸鸡的第二天，好饿。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>武汉肺炎</tag>
        <tag>一日三餐</tag>
      </tags>
  </entry>
</search>
